package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const version = "0.0.1-1"

const gofilesExt = ".go"

const (
	gogPrefix = "//gog:"
)

var (
	fileName = flag.String("f", "", "file name to be parsed, overriding the environment variable GOFILE value")
	recur    = flag.Bool("r", false, "scan current dir and sub directories")
	ver      = flag.Bool("v", "", "version")
)

var generators = map[string]Generatorer{}

func Register(gen Generatorer) {
	name := gen.Name()
	// TODO: don't allow if 'name' already exists
	generators[name] = gen
	log.Printf("Registering generator: %s\n", name)
}

type Generatorer interface {
	Imports(Struct) map[string]string
	Generate(Struct) []byte
	Name() string
}

func main() {
	flag.Parse()

	if *ver {
		fmt.Println("gog version", version)
	}

	fileToParse := getFileToParse()
	if fileToParse != "" {
		parseGoFileAndGenerateFile(fileToParse)
		return
	}

	if *recur {
		scanCurrentDirAndSubDirs()
		return
	}

	scanCurrentDir()
}

func scanCurrentDir() {
	files, err := ioutil.ReadDir(".")
	if err != nil {
		log.Fatal(err)
	}

	for _, file := range files {
		parseGoFileIfTagged(file.Name())
	}
}

func scanCurrentDirAndSubDirs() {
	currentDir := "."
	err := filepath.Walk(currentDir, func(path string, file os.FileInfo, err error) error {
		parseGoFileIfTagged(path)
		return nil
	})
	if err != nil {
		panic(err)
	}
}

func parseGoFileIfTagged(name string) {
	if filepath.Ext(name) == gofilesExt && isTagged(name) {
		parseGoFileAndGenerateFile(name)
	}
}

func isTagged(gofile string) bool {
	file, err := os.Open(gofile)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		// for now we are just handling tagged structs
		if strings.HasPrefix(line, gogPrefix) {
			return true
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return false
}

func getFileToParse() string {
	if *fileName != "" {
		return *fileName
	}

	return os.Getenv("GOFILE")
}

func parseGoFileAndGenerateFile(gofile string) {
	p := parseGoFile(gofile)

	var name = strings.Split(gofile, ".")[0]
	fileName := fmt.Sprintf("%s_gog.go", name)
	p.generateGoFile(fileName)
}

func parseGoFile(gofile string) *Parser {
	log.Println("Parsing", gofile)

	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, gofile, nil, parser.ParseComments)
	die(err, "parsing package: %s", gofile)

	return inspectGoFile(parsedFile)
}

func inspectGoFile(parsedFile *ast.File) *Parser {
	g := NewParser(parsedFile)

	ast.Inspect(parsedFile, g.genImp)
	ast.Inspect(parsedFile, g.genDecl)
	ast.Inspect(parsedFile, g.funcDecl)

	return g
}

func (p *Parser) generateGoFile(filename string) {
	code := p.generateCode()
	err := ioutil.WriteFile(filename, code, 0644)
	die(err, "Writing output")
}

func (p *Parser) generateCode() []byte {
	p.HPrintf("// Code generated by gog; DO NOT EDIT.\n")
	//g.Printf("// Generate at %s\n", time.Now().Format("2006-01-02 15:04:05 -0700"))
	p.HPrintf("package %s\n\n", p.parsedFile.Name.Name)

	for _, mapper := range p.Structs {
		for _, tag := range mapper.Tags {
			gen, ok := generators[tag.Name]
			if !ok {
				log.Printf("Could not find generator for %s", tag)
				continue
			}
			imports := gen.Imports(*mapper)
			for path, name := range imports {
				p.Imports[path] = name
			}

			src := gen.Generate(*mapper)
			p.Printf("\n")

			p.Printf("\n // Generated by gog:%s\n\n", gen.Name())
			p.Body.Write(src)
		}
	}

	for path, name := range p.Imports {
		p.HPrintf("import %s\"%s\"\n", name+" ", path)
	}

	src, err := format.Source(p.Flush())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
	}
	return src
}

func die(err error, msg string, args ...interface{}) {
	if err != nil {
		s := fmt.Sprintf(msg, args...)
		log.Fatal(s+":", err)
	}
}

type Parser struct {
	Scribler

	Imports    map[string]string
	Structs    []*Struct
	parsedFile *ast.File
}

func NewParser(parsedFile *ast.File) *Parser {
	return &Parser{
		Imports:    make(map[string]string),
		Structs:    make([]*Struct, 0),
		parsedFile: parsedFile,
	}
}

func (p *Parser) Parse(parsedFile *ast.File) {
	p.Imports = map[string]string{}
	p.Structs = []*Struct{}
}

func (p *Parser) genImp(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.IMPORT {
		// We only care about type declarations.
		return true
	}
	for _, spec := range decl.Specs {
		timport := spec.(*ast.ImportSpec)
		var name string
		if timport.Name != nil {
			name = timport.Name.Name
		}
		p.Imports[timport.Path.Value] = name
	}
	return false
}

func (p *Parser) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.TYPE {
		// We only care about type declarations.
		return true
	}
	for _, spec := range decl.Specs {
		tspec := spec.(*ast.TypeSpec)
		iType, ok := tspec.Type.(*ast.StructType)
		if ok && p.isMarkedForGeneration(decl) {
			aStruct := &Struct{
				Name:    tspec.Name.Name,
				Fields:  make([]Field, 0),
				Methods: make([]Method, 0),
			}
			p.Structs = append(p.Structs, aStruct)
			for _, astField := range iType.Fields.List {
				field := parseField(astField)
				aStruct.Fields = append(aStruct.Fields, field)
			}
			aStruct.Tags = extractTagsFromDoc(decl.Doc)
		}
	}

	return false
}

func (p *Parser) funcDecl(node ast.Node) bool {
	fn, ok := node.(*ast.FuncDecl)
	if !ok {
		return true
	}
	if fn.Recv != nil && len(fn.Recv.List) == 1 {
		field := fn.Recv.List[0]
		var expr ast.Expr
		startExpr, ok := field.Type.(*ast.StarExpr)
		if ok {
			expr = startExpr.X
		} else {
			expr = field.Type.(ast.Expr)
		}
		ident := expr.(*ast.Ident)
		for _, s := range p.Structs {
			if ident.Name == s.Name {
				// add to the list of methods
				m := parseType(fn.Type).(Method)
				method := Method{
					FuncName: fn.Name.Name,
					Args:     m.Args,
					Results:  m.Results,
				}
				s.Methods = append(s.Methods, method)
			}
		}
	}

	return false

}

func (p *Parser) isMarkedForGeneration(decl *ast.GenDecl) bool {
	if decl.Doc == nil {
		return false
	}
	for _, com := range decl.Doc.List {
		if p.hasValidGenerationPrefix(com.Text) {
			return true
		}
	}
	return false
}

func (p *Parser) hasValidGenerationPrefix(text string) bool {
	for tag := range generators {
		if strings.HasPrefix(text, gogPrefix+tag) {
			return true
		}
	}
	return false
}

func extractTagsFromDoc(doc *ast.CommentGroup) Tags {
	tags := make([]Tag, 0)
	if doc == nil {
		return tags
	}

	docs := make([]string, 0)
	for _, com := range doc.List {
		docs = append(docs, com.Text)
	}

	for _, line := range docs {
		if strings.HasPrefix(line, gogPrefix) {
			tag, arg := splitIntoTagAndArgs(line)
			tags = append(tags, Tag{tag, arg})
		}
	}
	return Tags(tags)
}

func splitIntoTagAndArgs(line string) (string, string) {
	str := strings.TrimSpace(line)
	offset := len(gogPrefix)
	firstSpace := strings.Index(str, " ")
	if firstSpace == -1 {
		return str[offset:], ""
	}
	return str[offset:firstSpace], str[offset+firstSpace:]
}

func parseField(astField *ast.Field) Field {
	//fmt.Println("====> Comment:", astField.Doc.Text())
	var field Field
	field.Kind = parseType(astField.Type)
	if len(astField.Names) > 0 {
		field.Name = astField.Names[0].Name
	}

	field.Tags = extractTagsFromDoc(astField.Doc)
	return field
}

func parseType(expr ast.Expr) Kinder {
	var kind Kinder
	switch n := expr.(type) {
	// TODO: Map type
	// if the type is imported
	case *ast.MapType:
		key := parseType(n.Key)
		val := parseType(n.Value)
		kind = Map{key, val}
	case *ast.ArrayType:
		kind = Array{parseType(n.Elt)}
	case *ast.SelectorExpr:
		pck := n.X.(*ast.Ident)
		kind = Basic{pck.Name + "." + n.Sel.Name}
	case *ast.StarExpr:
		kind = Pointer{parseType(n.X)}
	case *ast.Ident:
		kind = Basic{Type: n.Name}
	case *ast.FuncType:

		args := []Field{}
		results := []Field{}
		for _, p := range n.Params.List {
			//fmt.Printf("====> Param: %s, %#v\n", p.Type, p.Type)
			arg := parseField(p)
			args = append(args, arg)
		}
		for _, res := range n.Results.List {
			result := parseField(res)
			results = append(results, result)
		}
		kind = Method{Args: args, Results: results}
	}
	return kind
}

func UncapFirst(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}

type Scribler struct {
	Header bytes.Buffer
	Body   bytes.Buffer
}

func (s *Scribler) HPrintf(format string, args ...interface{}) {
	fmt.Fprintf(&s.Header, format, args...)
}

func (s *Scribler) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&s.Body, format, args...)
}

func (s *Scribler) Flush() []byte {
	head := s.Header.Bytes()
	s.Header.Reset()
	body := s.Body.Bytes()
	s.Body.Reset()
	return append(head, body...)
}
