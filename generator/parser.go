package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/quintans/gog/config"
	"golang.org/x/tools/imports"
)

const (
	goFilesExt     = ".go"
	goTestFilesExt = "_test.go"

	gogPrefix = "// gog:"

	printErrorOffset = 3
)

var genSuffix = "gen"

func SetGenSuffix(s string) {
	genSuffix = s
}

var generators = map[string]Plugin{}

func UnregisterAll() {
	generators = map[string]Plugin{}
}

func Unregister(gen Plugin) {
	name := gen.Name()
	delete(generators, name)
	log.Printf("Unregistered generator: %s\n", name)
}

func Register(gen Plugin) {
	name := gen.Name()
	// TODO: don't allow if 'name' already exists
	generators[name] = gen
	log.Printf("Registered generator: %s\n", name)
}

type Plugin interface {
	Accepts() []MapperType
	Imports(Mapper) map[string]string
	GenerateBody(Mapper) error
	Name() string
	Flush() []byte
}

type ScanOptions struct {
	dirOut string
}

type ScanOption func(*ScanOptions)

func WithDirOut(dirOut string) ScanOption {
	return func(so *ScanOptions) {
		so.dirOut = dirOut
	}
}

func ScanCurrentDir(options ...ScanOption) {
	ScanDir(".", options...)
}

func ScanDir(dir string, options ...ScanOption) {
	files, err := os.ReadDir(dir)
	if err != nil {
		log.Fatal(err)
	}

	wd, err := os.Getwd()
	if err != nil {
		log.Println(err)
	}

	for _, file := range files {
		parseAndGenerateIfTagged(wd, file.Name(), dir, options...)
	}
}

func ScanCurrentDirAndSubDirs(options ...ScanOption) {
	ScanDirAndSubDirs(".", options...)
}

func ScanDirAndSubDirs(dir string, options ...ScanOption) {
	wd, err := os.Getwd()
	if err != nil {
		log.Println(err)
	}

	absDir, err := filepath.Abs(dir)
	if err != nil {
		log.Fatal(err)
	}

	err = filepath.Walk(absDir, func(path string, file os.FileInfo, err error) error {
		parseAndGenerateIfTagged(wd, path, absDir, options...)
		return nil
	})
	if err != nil {
		panic(err)
	}
}

func parseAndGenerateIfTagged(workDir, fullFileName, dirIn string, options ...ScanOption) {
	if strings.HasSuffix(fullFileName, goFilesExt) && !strings.HasSuffix(fullFileName, goTestFilesExt) && isTagged(fullFileName) {
		parseGoFileAndGenerateFile(workDir, fullFileName, dirIn, options...)
	}
}

func isTagged(gofile string) bool {
	file, err := os.Open(gofile)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		// for now we are just handling tagged structs
		if strings.HasPrefix(line, gogPrefix) {
			return true
		}
	}

	if err := scanner.Err(); err != nil {
		log.Panic(err)
	}

	return false
}

func ScanAndGenerateFile(workDir, fullFileName string) {
	parseGoFileAndGenerateFile(workDir, fullFileName, "")
}

func parseGoFileAndGenerateFile(workDir, fullFileName, dirIn string, options ...ScanOption) {
	if !strings.HasSuffix(fullFileName, goFilesExt) {
		log.Fatalf("invalid file: %s", fullFileName)
	}

	relativePath := strings.Replace(fullFileName, workDir, "", 1)
	relativePathToRoot := strings.Split(relativePath, string(os.PathSeparator))

	name := fullFileName[:len(fullFileName)-len(goFilesExt)]
	fileName := fmt.Sprintf("%s_%s.go", name, genSuffix)

	// drop file name
	relativePathToRoot = relativePathToRoot[:len(relativePathToRoot)-1]

	p := parseGoFile(relativePathToRoot, fullFileName)

	opts := ScanOptions{}
	for _, opt := range options {
		opt(&opts)
	}

	if opts.dirOut != "" && opts.dirOut != dirIn {
		fileName = strings.Replace(fileName, dirIn, opts.dirOut, 1)
	}
	p.generateGoFile(fileName)
}

func parseGoFile(relativePathToRoot []string, gofile string) *Parser {
	log.Println("Parsing", gofile)

	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, gofile, nil, parser.ParseComments)
	die(err, "parsing package: %s", gofile)

	return InspectGoFile(relativePathToRoot, parsedFile)
}

func InspectGoFile(relativePathToRoot []string, parsedFile *ast.File) *Parser {
	g := NewParser(parsedFile)

	ast.Inspect(parsedFile, g.genImp)
	ast.Inspect(parsedFile, func(n ast.Node) bool {
		return g.genDecl(relativePathToRoot, n)
	})

	ast.Inspect(parsedFile, g.funcDecl)

	return g
}

func die(err error, msg string, args ...interface{}) {
	if err != nil {
		log.Fatalf(msg+": %v", append(args, err)...)
	}
}

type Parser struct {
	Scribler

	Imports    map[string]string
	Mappers    []Mapper
	generators map[string]Plugin
	parsedFile *ast.File
}

func NewParser(parsedFile *ast.File) *Parser {
	return &Parser{
		Imports:    make(map[string]string),
		generators: generators,
		parsedFile: parsedFile,
	}
}

func (p *Parser) generateGoFile(filename string) {
	code, err := p.GenerateCode(filename)
	die(err, "Generating code")
	err = os.WriteFile(filename, code, 0o644)
	die(err, "Writing output")
}

func (p *Parser) GenerateCode(filename string) ([]byte, error) {
	p.HPrintf("// Code generated by gog; DO NOT EDIT.\n")
	p.HPrintf("// Version: %s\n", config.Version)
	p.HPrintf("package %s\n\n", p.parsedFile.Name.Name)

	for _, mapper := range p.Mappers {
		err := p.generate(mapper)
		if err != nil {
			return nil, err
		}
	}

	for path, name := range p.Imports {
		p.HPrintf("import %s %s\n", name, path)
	}
	code := p.Flush()
	src, err := imports.Process(filename, code, nil)
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		errMsg := err.Error()
		log.Printf("warning: internal error: invalid Go generated: %s", errMsg)
		printLine(string(code), errMsg)
		log.Printf("warning: compile the package to analyze the error")
		return code, nil
	}
	return src, nil
}

func (p *Parser) generate(mapper Mapper) error {
	for _, tag := range mapper.GetTags() {
		gen, ok := p.generators[tag.Name]
		if !ok {
			log.Printf("Could not find plugin for %s", tag)
			continue
		}

		if !Contains(gen.Accepts(), mapper.Type()) {
			log.Printf("Plugin %s can't handle %s", tag, mapper.Type())
			continue
		}

		err := gen.GenerateBody(mapper)
		if err != nil {
			return err
		}

		p.BPrintf("\n")

		s := gen.Flush()
		p.BPrintf("\n // Generated by gog:%s\n\n%s", gen.Name(), s)

		imps := gen.Imports(mapper)
		for path, name := range imps {
			p.Imports[path] = name
		}
	}
	return nil
}

func printLine(code, errMsg string) {
	left := strings.Index(errMsg, ":") + 1
	right := strings.Index(errMsg[left:], ":")
	line, err := strconv.Atoi(errMsg[left : left+right])
	if err != nil {
		log.Printf("> failed to identify line from: %s: %s", errMsg, err)
		return
	}
	lower := line - printErrorOffset
	upper := line + printErrorOffset
	scanner := bufio.NewScanner(strings.NewReader(code))
	cnt := 0
	for scanner.Scan() {
		cnt++
		if cnt >= lower && cnt <= upper {
			if cnt == line {
				log.Printf("> %d: %s", cnt, scanner.Text())
			} else {
				log.Printf("  %d: %s", cnt, scanner.Text())
			}
		}
		if cnt > upper {
			return
		}
	}
}

func (p *Parser) genImp(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.IMPORT {
		// We only care about type declarations.
		return true
	}
	for _, spec := range decl.Specs {
		timport := spec.(*ast.ImportSpec)
		var name string
		if timport.Name != nil {
			name = timport.Name.Name
		}
		p.Imports[timport.Path.Value] = name
	}
	return false
}

func (p *Parser) genDecl(relativePathToRoot []string, node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.TYPE {
		// We only care about type declarations.
		return true
	}
	for _, spec := range decl.Specs {
		tspec := spec.(*ast.TypeSpec)
		switch iType := tspec.Type.(type) {
		case *ast.StructType:
			aStruct := &Struct{
				Name:    tspec.Name.Name,
				Fields:  make([]Field, 0),
				Methods: make([]Method, 0),
				Dir:     relativePathToRoot,
				Package: p.parsedFile.Name.Name,
			}
			p.Mappers = append(p.Mappers, aStruct)
			for _, astField := range iType.Fields.List {
				field := parseField(astField)
				aStruct.Fields = append(aStruct.Fields, field)
			}
			aStruct.Tags = extractTagsFromDoc(decl.Doc)
		case *ast.InterfaceType:
			aInterface := &Interface{
				Name:    tspec.Name.Name,
				Dir:     relativePathToRoot,
				Package: p.parsedFile.Name.Name,
			}
			for _, astField := range iType.Methods.List {
				mName := astField.Names[0].Name
				m := parseType(astField.Type).(*Method)
				method := Method{
					Tags:     extractTagsFromDoc(astField.Doc),
					FuncName: mName,
					Args:     m.Args,
					Results:  m.Results,
				}
				aInterface.Methods = append(aInterface.Methods, method)
			}
			aInterface.Tags = extractTagsFromDoc(decl.Doc)
			p.Mappers = append(p.Mappers, aInterface)
		}
	}

	return false
}

func (p *Parser) funcDecl(node ast.Node) bool {
	fn, ok := node.(*ast.FuncDecl)
	if !ok {
		return true
	}
	if fn.Recv != nil && len(fn.Recv.List) == 1 {
		field := fn.Recv.List[0]
		var expr ast.Expr
		startExpr, ok := field.Type.(*ast.StarExpr)
		if ok {
			expr = startExpr.X
		} else {
			expr = field.Type
		}
		ident := expr.(*ast.Ident)
		for _, s := range p.Mappers {
			if ident.Name == s.GetName() {
				// add to the list of methods
				m := parseType(fn.Type).(*Method)
				method := Method{
					Tags:     extractTagsFromDoc(fn.Doc),
					FuncName: fn.Name.Name,
					Args:     m.Args,
					Results:  m.Results,
				}
				s.AddMethod(method)
			}
		}
	}

	return false
}

func extractTagsFromDoc(doc *ast.CommentGroup) Tags {
	tags := make([]Tag, 0)
	if doc == nil {
		return tags
	}

	docs := make([]string, 0)
	for _, com := range doc.List {
		docs = append(docs, com.Text)
	}

	for _, line := range docs {
		if strings.HasPrefix(line, gogPrefix) {
			tag, arg := splitIntoTagAndArgs(line)
			tags = append(tags, Tag{tag, arg})
		}
	}
	return Tags(tags)
}

func splitIntoTagAndArgs(line string) (tag, rawArgs string) {
	str := strings.TrimSpace(line)
	offset := len(gogPrefix)
	firstSpace := strings.Index(str[offset:], " ")
	if firstSpace == -1 {
		return str[offset:], ""
	}
	return str[offset : offset+firstSpace], str[offset+firstSpace+1:]
}

func parseField(astField *ast.Field) Field {
	var field Field
	field.Kind = parseType(astField.Type)
	if len(astField.Names) > 0 {
		field.Name = astField.Names[0].Name
	}

	field.Tags = extractTagsFromDoc(astField.Doc)
	return field
}

func parseType(expr ast.Expr) Kinder {
	var kind Kinder
	switch n := expr.(type) {
	// TODO: Map type
	// if the type is imported
	case *ast.MapType:
		key := parseType(n.Key)
		val := parseType(n.Value)
		kind = Map{key, val}
	case *ast.ArrayType:
		kind = Array{parseType(n.Elt)}
	case *ast.SelectorExpr:
		pck := n.X.(*ast.Ident)
		kind = Basic{Pck: pck.Name, Type: n.Sel.Name}
	case *ast.StarExpr:
		kind = Pointer{parseType(n.X)}
	case *ast.Ident:
		kind = Basic{Type: n.Name}
	case *ast.InterfaceType:
		if n.Methods == nil || len(n.Methods.List) == 0 {
			kind = &InterfaceVar{}
		}
	case *ast.FuncType:
		args := []Field{}
		results := []Field{}
		if n.Params != nil {
			for _, p := range n.Params.List {
				arg := parseField(p)
				args = append(args, arg)
			}
		}
		if n.Results != nil {
			for _, res := range n.Results.List {
				result := parseField(res)
				results = append(results, result)
			}
		}
		kind = &Method{Args: args, Results: results}
	default:
		fmt.Printf("not handling type %T\n", n)
	}
	return kind
}

type Scribler struct {
	Header bytes.Buffer
	Body   bytes.Buffer
}

func (s *Scribler) HPrintf(format string, args ...interface{}) {
	fmt.Fprintf(&s.Header, format, args...)
}

func (s *Scribler) HPrint(args ...interface{}) {
	fmt.Fprint(&s.Header, args...)
}

func (s *Scribler) HPrintln(args ...interface{}) {
	fmt.Fprint(&s.Header, args...)
	fmt.Fprint(&s.Header, "\n")
}

func (s *Scribler) BPrintf(format string, args ...interface{}) {
	fmt.Fprintf(&s.Body, format, args...)
}

func (s *Scribler) BPrint(args ...interface{}) {
	fmt.Fprint(&s.Body, args...)
}

func (s *Scribler) BPrintln(args ...interface{}) {
	fmt.Fprint(&s.Body, args...)
	fmt.Fprint(&s.Body, "\n")
}

func (s *Scribler) Flush() []byte {
	head := s.Header.Bytes()
	s.Header.Reset()
	body := s.Body.Bytes()
	s.Body.Reset()
	return append(head, body...)
}

func (s Scribler) String() string {
	head := s.Header.Bytes()
	body := s.Body.Bytes()
	return string(append(head, body...))
}

func (s Scribler) Len() int {
	return s.Header.Len() + s.Body.Len()
}
