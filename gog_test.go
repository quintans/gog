package main

import (
	"go/parser"
	"go/token"
	"testing"

	"github.com/andreyvit/diff"
)

func TestAllArgsConstructor(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"AllArgsConstructor 1 required",
			`
package p

//gog:allArgsConstructor
type Foo struct {
	//gog:@required
	name  string
	value int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:allArgsConstructor

func NewFoo(name string) Foo {
	return Foo{
		name: name,
	}
}
`,
		},
		{
			"AllArgsConstructor many required",
			`
package p

//gog:allArgsConstructor
type Foo struct {
	//gog:@required
	name  string
	//gog:@required
	value int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:allArgsConstructor

func NewFoo(name string, value int64) Foo {
	return Foo{
		name:  name,
		value: value,
	}
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func TestBuilder(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"Builder",
			`
package p

//gog:builder
type Foo struct {
	Bar
	//gog:@required
	name  string
	value int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

import "errors"

// Generated by gog:builder

type FooBuilder struct {
	Bar
	name        string
	nameDefined bool
	value       int64
}

func NewFooBuilder() *FooBuilder { return &FooBuilder{} }

func (b *FooBuilder) WithBar(bar Bar) *FooBuilder {
	b.Bar = bar
	return b
}

func (b *FooBuilder) Name(name string) *FooBuilder {
	b.nameDefined = true
	b.name = name
	return b
}

func (b *FooBuilder) Value(value int64) *FooBuilder {
	b.value = value
	return b
}

func (b *FooBuilder) Build() (*Foo, error) {
	if !b.nameDefined {
		return nil, errors.New("Field name is required.")
	}

	s := &Foo{}
	s.Bar = b.Bar
	s.name = b.name
	s.value = b.value

	return s, nil
}

func (src Foo) ToBuild() *FooBuilder {
	return &FooBuilder{
		Bar:   src.Bar,
		name:  src.name,
		value: src.value,
	}
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func TestValue(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"Builder",
			`
package p

//gog:value
type Foo struct {
	name  string
	value []Bar
	pairs map[Bar]Thing
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

import "github.com/quintans/gog"

// Generated by gog:value

func (t Foo) Name() string {
	return t.name
}

func (t Foo) Value() []Bar {
	if len(t.value) == 0 {
		return t.value
	}

	others := make([]Bar, len(t.value))
	// check that the type of the array is clonable
	if _, ok := t.value[0].(gog.Cloner); ok {
		for k, v := range t.value {
			t := v.(gog.Cloner)
			others[k] = t.Clone().(Bar)
		}
		return others
	}

	for k, v := range t.value {
		others[k] = t.value[k]
	}
	return others
}

func (t Foo) Pairs() map[Bar]Thing {
	if len(t.pairs) == 0 {
		return t.pairs
	}

	others := map[Bar]Thing{}
	for k, v := range t.pairs {
		var key Bar
		if t, ok := k.(gog.Cloner); ok {
			key = t.Clone().(Bar)
		} else {
			key = k
		}
		var val Thing
		if t, ok := v.(gog.Cloner); ok {
			val = t.Clone().(Thing)
		} else {
			val = v
		}
		others[key] = val
	}
	return others
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func run(t *testing.T, in string, out string) {
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "src.go", in, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	code := inspectGoFile(f).generateCode()
	src := string(code)
	if src != out {
		t.Errorf("\ngot----------\n%swant----------\n%s-----------\n%s", src, out, diff.CharacterDiff(out, src))
	}
}
