package plugins

import (
	"go/parser"
	"go/token"
	"testing"

	"github.com/andreyvit/diff"
	"github.com/quintans/gog/generator"
)

func TestAllArgsConstructor(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"RequiredArgsConstructor 1 required",
			`
package p

//gog:requiredArgsConstructor
type Foo struct {
	//gog:@required
	name  string
	value int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:requiredArgsConstructor

func NewFooRequired(name string) Foo {
	return Foo{
		name: name,
	}
}
`,
		},
		{
			"RequiredArgsConstructor many required",
			`
package p

//gog:requiredArgsConstructor
type Foo struct {
	//gog:@required
	name  string
	//gog:@required
	value int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:requiredArgsConstructor

func NewFooRequired(name string, value int64) Foo {
	return Foo{
		name:  name,
		value: value,
	}
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func TestBuilder(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"Builder",
			`
package p

// this import is removed
import "errors"

//gog:builder
type Foo struct {
	Bar
	//gog:@required
	name    string
	value   int64
	timeout int64
}

func (f *Foo) SetValue(value int64) {
	f.value = value
}

func (f *Foo) SetTimeout(timeout int64) error {
	if timeout < 0 {
		return errors.New("timeout must be > 0")
	}
	f.timeout = timeout
	return nil
}

`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:builder

type FooBuilder struct {
	Bar
	name    string
	value   int64
	timeout int64
}

func NewFooBuilder(name string) *FooBuilder {
	return &FooBuilder{
		name: name,
	}
}

func (b *FooBuilder) WithBar(bar Bar) *FooBuilder {
	b.Bar = bar
	return b
}

func (b *FooBuilder) Name(name string) *FooBuilder {
	b.name = name
	return b
}

func (b *FooBuilder) Value(value int64) *FooBuilder {
	b.value = value
	return b
}

func (b *FooBuilder) Timeout(timeout int64) *FooBuilder {
	b.timeout = timeout
	return b
}

func (b *FooBuilder) Build() (*Foo, error) {
	s := &Foo{}
	s.Bar = b.Bar
	s.name = b.name
	s.SetValue(b.value)
	if err := s.SetTimeout(b.timeout); err != nil {
		return nil, err
	}

	return s, nil
}

func (src *Foo) ToBuild() *FooBuilder {
	return &FooBuilder{
		Bar:     src.Bar,
		name:    src.name,
		value:   src.value,
		timeout: src.timeout,
	}
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func TestValue(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"Value",
			`
package p

//gog:value
type Foo struct {
	name  string
	value []Bar
	pairs map[Bar]Thing
	//gog:@wither
	age   int
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:value

func NewFoo(name string, value []Bar, pairs map[Bar]Thing, age int) Foo {
	return Foo{
		name:  name,
		value: value,
		pairs: pairs,
		age:   age,
	}
}

func (t Foo) Name() string {
	return t.name
}

func (t Foo) Value() []Bar {
	return t.value
}

func (t Foo) Pairs() map[Bar]Thing {
	return t.pairs
}

func (t Foo) Age() int {
	return t.age
}

func (t Foo) WithAge(age int) Foo {
	return Foo{
		name:  t.name,
		value: t.value,
		pairs: t.pairs,
		age:   age,
	}
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func TestOption(t *testing.T) {
	var tests = []struct {
		name string
		in   string
		out  string
	}{
		{
			"Option Simple",
			`
package p

//gog:options
type Foo struct {
	name  string
	timeout int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:options

func FooName(name string) func(*Foo) {
	return func(t *Foo) {
		t.name = name
	}
}

func FooTimeout(timeout int64) func(*Foo) {
	return func(t *Foo) {
		t.timeout = timeout
	}
}

func NewFooOptions(options ...func(*Foo)) *Foo {
	t := &Foo{}
	for _, option := range options {
		option(t)
	}
	return t
}
`,
		},
		{
			"Option required and ignore",
			`
package p

//gog:options
type Foo struct {
	//gog:@required
	name  string
	//gog:@ignore
	value []Bar
	timeout int64
}
`,
			`// Code generated by gog; DO NOT EDIT.
package p

// Generated by gog:options

func FooTimeout(timeout int64) func(*Foo) {
	return func(t *Foo) {
		t.timeout = timeout
	}
}

func NewFooOptions(name string, options ...func(*Foo)) *Foo {
	t := &Foo{
		name: name,
	}
	for _, option := range options {
		option(t)
	}
	return t
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

func run(t *testing.T, in string, out string) {
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "src.go", in, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	code := generator.InspectGoFile(f).GenerateCode("src.go")
	src := string(code)
	if src != out {
		t.Errorf("\ngot----------\n%swant----------\n%s-----------\n%s", src, out, diff.CharacterDiff(out, src))
	}
}
