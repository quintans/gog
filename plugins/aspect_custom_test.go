package plugins

import (
	"fmt"
	"strings"
	"testing"

	"github.com/quintans/gog/config"
	"github.com/quintans/gog/generator"
)

const (
	AspectTxTag      = "@tx"
	AspectMonitorTag = "@monitor"
	AspectSecuredTag = "@secured"
)

// Example of how to build a custom aspect generator

func TestCustomPlugin(t *testing.T) {
	generator.Register(&Aspect{})

	tests := []struct {
		name string
		in   string
		out  string
	}{
		{
			name: "monitor_aspect",
			in: `
			package p

			import "context"
			
			// gog:aspect
			type Foo struct{}
			
			// gog:@monitor {"threshold": 1}
			// gog:@tx
			func (f Foo) Handle(ctx context.Context, code string) (int, error) {
				fmt.Println("receive code:", code)
				return 1, nil
			}

			// gog:@secured {"roles": ["user"]}
			func (f Foo) WhoAmI(ctx context.Context) (string, error) {
				// gets user from context, whatever
				return "myname", nil
			}

			// Dummy demonstrates without aspect
			func (f Foo) Dummy(ctx context.Context) int {
				return 1000
			}
			`,
			out: fmt.Sprintf(`// Code generated by gog; DO NOT EDIT.
// Version: %s
package p

import (
	"context"
	"fmt"
	"time"
)

// Generated by gog:aspect

type FooAspect struct {
	Next Foo
}

func (a *FooAspect) Handle(ctx context.Context, code string) (int, error) {
	// tx aspect
	f1 := func(ctx context.Context, code string) (int, error) {
		var a0 int
		var a1 error
		txErr := fake.WithTx(ctx, func(s string) error {
			a0, a1 = a.Next.Handle(ctx, code)
			return a1
		}) // end of WithTx
		a1 = txErr
		return a0, a1
	} // end of tx

	// monitor aspect
	f0 := func(ctx context.Context, code string) (int, error) {
		now := time.Now()
		defer func() {
			if time.Since(now) > 1*time.Second {
				fmt.Println("slow call")
			}
		}()
		return f1(ctx, code)
	}

	return f0(ctx, code)
}

func (a *FooAspect) WhoAmI(ctx context.Context) (string, error) {
	// secured aspect
	f0 := func(ctx context.Context) (string, error) {
		if err := checkSecurity(ctx, "user"); err != nil {
			return "", err
		}
		a.Next.WhoAmI(ctx)
	}

	return f0(ctx)
}

func (a *FooAspect) Dummy(ctx context.Context) int {
	return a.Next.Dummy(ctx)
}
`, config.Version),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}

type AspectOptions struct{}

type Aspect struct {
	generator.Scribler
}

func (a Aspect) Name() string {
	return "aspect"
}

func (a Aspect) Imports(mapper generator.Struct) map[string]string {
	return map[string]string{}
}

func (a *Aspect) GenerateBody(mapper generator.Struct) error {
	return a.WriteBody(mapper, AspectOptions{})
}

func (a *Aspect) WriteBody(mapper generator.Struct, _ AspectOptions) error {
	sName := mapper.Name + "Aspect"
	a.BPrintf("type %sAspect struct {\n", mapper.Name)
	a.BPrintf("Next %s\n", mapper.Name)
	a.BPrintf("}\n\n")

	for _, m := range mapper.Methods {
		a.BPrint("func (a *", sName, ") ", m.Signature(true), " {\n")

		methodName := "a.Next." + m.Name()

		var found bool
		for k := len(m.Tags) - 1; k >= 0; k-- {
			var body string

			tag := m.Tags[k]
			switch tag.Name {
			case AspectMonitorTag:
				found = true
				a.BPrintln("// monitor aspect")
				options := AspectMonitorOptions{}
				if err := tag.Unmarshal(&options); err != nil {
					return err
				}
				body = monitor(m, methodName, options)
			case AspectTxTag:
				found = true
				a.BPrintln("// tx aspect")
				body = tx(m, methodName)
			case AspectSecuredTag:
				found = true
				a.BPrintln("// secured aspect")
				options := AspectSecuredOptions{}
				if err := tag.Unmarshal(&options); err != nil {
					return err
				}
				body = secured(m, methodName, options)
			default:
				continue
			}
			methodName = fmt.Sprintf("f%d", k)
			a.BPrint(methodName, " := ", body, "\n")
		}

		call := fmt.Sprint("(", m.Parameters(true), ")")
		if found {
			a.BPrintln("return f0", call)
		} else {
			a.BPrintln("return ", methodName, call)
		}
		a.BPrint("}\n\n")
	}

	return nil
}

type AspectMonitorOptions struct {
	Threshold int
}

type AspectSecuredOptions struct {
	Roles []string
}

func monitor(m generator.Method, methodName string, options AspectMonitorOptions) string {
	sign := m.Signature(false)
	s := generator.Scribler{}
	s.BPrintf(`func%s{
		now := time.Now()
		defer func(){
			if time.Since(now) > %d*time.Second {
				fmt.Println("slow call")
			}
		}()
	`, sign, options.Threshold)
	if m.HasResults() {
		s.BPrintf("return ")
	}
	s.BPrintln(methodName, "(", m.Parameters(true), ")")
	s.BPrintln("}")

	return s.String()
}

func secured(m generator.Method, methodName string, options AspectSecuredOptions) string {
	sign := m.Signature(false)
	s := generator.Scribler{}
	s.BPrintf(`func%s{
		if err := checkSecurity(ctx, %s); err != nil {
			return %s
		}
		`, sign, generator.JoinAround(options.Roles, "\"", "\"", ", "), m.ReturnZerosWithError("err"))

	s.BPrintln(methodName, "(", m.Parameters(true), ")")
	s.BPrintln("}")

	return s.String()
}

func tx(m generator.Method, methodName string) string {
	sign := m.Signature(false)
	s := generator.Scribler{}
	s.BPrintf("func%s{\n", sign)

	// return vars
	var errorVar string
	rets := make([]string, 0, len(m.Results))

	for k, a := range m.Results {
		r := fmt.Sprintf("a%d", k)
		s.BPrintf("var %s %s\n", r, a.Kind)
		rets = append(rets, r)
		if a.IsError() {
			errorVar = r
		}
	}
	s.BPrintln("txErr := fake.WithTx(ctx, func(s string) error {")
	s.BPrintln(strings.Join(rets, ","), " = ", methodName, "(", m.Parameters(true), ")")
	if errorVar != "" {
		s.BPrintln("return ", errorVar)
	} else {
		s.BPrintln("return nil")
	}
	s.BPrintln("}) // end of WithTx") // ends WithTx

	if errorVar != "" {
		s.BPrintln(errorVar, " = txErr")
	}
	s.BPrintln("return ", strings.Join(rets, ","))
	s.BPrintln("} // end of tx")

	return s.String()
}
