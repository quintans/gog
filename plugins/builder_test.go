package plugins

import (
	"fmt"
	"testing"

	"github.com/quintans/gog/config"
)

func TestBuilder(t *testing.T) {
	tests := []struct {
		name string
		in   string
		out  string
	}{
		{
			"Builder",
			`
package p

import (
	"errors"
	"time"
)

// gog:builder
type Foo struct {
	Bar
	// gog:@required
	name string
	// gog:@required
	when    time.Time
	timeout time.Duration
}

func (f Foo) validate() error {
	if timeout < 0 {
		return errors.New("timeout must be > 0")
	}
	return nil
}

`,
			fmt.Sprintf(`// Code generated by gog; DO NOT EDIT.
// Version: %s
package p

import (
	"errors"
	"fmt"
	"time"
)

// Generated by gog:builder

type FooBuilder struct {
	Bar
	name    string
	when    time.Time
	timeout time.Duration
}

func NewFooBuilder(name string, when time.Time) *FooBuilder {
	return &FooBuilder{
		name: name,
		when: when,
	}
}

func (b *FooBuilder) WithBar(bar Bar) *FooBuilder {
	b.Bar = bar
	return b
}

func (b *FooBuilder) Name(name string) *FooBuilder {
	b.name = name
	return b
}

func (b *FooBuilder) When(when time.Time) *FooBuilder {
	b.when = when
	return b
}

func (b *FooBuilder) Timeout(timeout time.Duration) *FooBuilder {
	b.timeout = timeout
	return b
}

func (b *FooBuilder) Build() (Foo, error) {
	if b.name == "" {
		return Foo{}, errors.New("Foo.name cannot be empty")
	}
	if (b.when == time.Time{}) {
		return Foo{}, errors.New("Foo.when cannot be empty")
	}
	s := Foo{
		Bar:     b.Bar,
		name:    b.name,
		when:    b.when,
		timeout: b.timeout,
	}

	if err := s.validate(); err != nil {
		return Foo{}, err
	}

	return s, nil
}

func (b *Foo) ToBuild() *FooBuilder {
	return &FooBuilder{
		Bar:     b.Bar,
		name:    b.name,
		when:    b.when,
		timeout: b.timeout,
	}
}

func (f Foo) GetBar() Bar {
	return f.Bar
}

func (f Foo) Name() string {
	return f.name
}

func (f Foo) When() time.Time {
	return f.when
}

func (f Foo) Timeout() time.Duration {
	return f.timeout
}

func (f Foo) IsZero() bool {
	return f == Foo{}
}

func (f Foo) String() string {
	return fmt.Sprintf("Foo{Bar: %%+v, name: %%+v, when: %%+v, timeout: %%+v}", f.Bar, f.name, f.when, f.timeout)
}
`, config.Version),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			run(t, tt.in, tt.out)
		})
	}
}
